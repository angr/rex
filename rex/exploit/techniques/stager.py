"""
FIXME
This technique is a HACK!!!
It should be rewritten to be something like CrashManager
to handle multi-stage exploitation properly
"""
import logging

import angr
from angrop.errors import RopException

from ...vulnerability import Vulnerability
from ..technique import Technique
from .. import Exploit, CannotExploit

l = logging.getLogger("rex.exploit.techniques.stager")

class Stager(Technique):

    name = "stager"
    applicable_to = ['unix']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stagers = []

    def _is_valid(self, addr):
        if not addr:
            return False
        state = self.crash.state
        if not state.satisfiable(extra_constraints=[state.regs.pc == addr]):
            l.debug("The stager function @ %#x could not be called" % addr)
            return False
        return True

    def check(self):
        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            self.check_fail_reason("Cannot control IP.")
            return False

        # TODO: in case the target reads from stdin, gets is a prefered stager function
        # TODO: recv is also a good stager function
        read_plt_addr = self._find_func_address("read")
        if self._is_valid(read_plt_addr):
            self.stagers.append(read_plt_addr)
        read_addr = self._find_libc_func_address("read")
        if self._is_valid(read_addr):
            self.stagers.append(read_addr)

        if not self.stagers:
            self.check_fail_reason("No valid stager function...")
            return False

        return True

    def _invoke_stager(self):
        pass

    def apply(self, **kwargs):# pylint:disable=arguments-differ
        print(self.crash.trace_result.taint_fd)
        print("apply")
        import IPython; IPython.embed()
        return Exploit(self.crash, bypasses_nx=True, bypasses_aslr=False)
