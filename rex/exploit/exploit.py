import binascii
import logging
import os

from textwrap import dedent

import angr
from angr.storage.file import SimFileDescriptorDuplex

from ..enums import CrashInputType
from ..scripter import Scripter

l = logging.getLogger("rex.exploit.exploit")


class ExploitException(Exception):
    pass


class Exploit:
    """
    An Exploit object represents the successful application of an exploit technique to a crash state.

    It contains the logic for extracting an understanding of how to interact with a state in order to reproduce it
    concretely, and then the logic for encoding that understanding as an exploit script.
    """

    def __init__(self, crash, bypasses_nx, bypasses_aslr, target_instruction_pointer = None):
        """
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param bypasses_nx: does the exploit bypass NX?
        :param bypasses_aslr: does the exploit bypass ASLR?
        :param target_ip_addr: what is the address that we are trying to control? This way we can parameterize it a bit
        """

        self.bypasses_nx = bypasses_nx
        self.bypasses_aslr = bypasses_aslr

        self.crash = crash
        self.binary = crash.binary
        self.project = crash.project

        self.exploit_state = crash.state

        self.target_instruction_pointer = target_instruction_pointer

    def _at_syscall(self, path):
        """
        Is the current path at a syscall instruction? Will it make a syscall next step?
        :param path: the path to test
        :return: True if a syscall will be executed next step
        """

        return self.project.factory.block(path.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def dump(self, filename=None):
        """
        default behavior for payload dumper
        """

        # Determine where data goes (stdin/tcp)

        if self.crash.input_type in (CrashInputType.STDIN, CrashInputType.POV_FILE):
            exploit_input = self.crash.state.posix.stdin  # stdin
        elif self.crash.input_type == CrashInputType.TCP:
            # determine which TCP socket file the input is coming from
            sock_fds = [ fd for fd_no, fd in self.crash.state.posix.fd.items() if fd_no not in (0, 1, 2) ] + \
                       [ fd for _, fd in self.crash.state.posix.closed_fds ]
            for simfd in sock_fds:
                if isinstance(simfd, SimFileDescriptorDuplex) and \
                        simfd.read_storage.ident.startswith("aeg_stdin") and \
                        self.crash.state.solver.eval(simfd.read_pos) > 0:
                    # found it!
                    exploit_input = simfd.read_storage
                    break
            else:
                raise ExploitException("Cannot find the exploit input file descriptor.")

        else:
            raise NotImplementedError("CrashInputType %s is not supported yet." % self.crash.input_type)

        data = exploit_input.concretize()
        if isinstance(data, tuple):
            data = data[0]
        if filename:
            with open(filename, "wb") as f:
                f.write(data)
        return data

    def script(self, template='python', filename=None):
        scripter = Scripter(template, ['IP', 'PORT'])
        scripter.PAYLOAD = self.dump()
        scripter.sock = int, scripter.connect_target()
        scripter.send_all(scripter.sock, scripter.PAYLOAD, len(scripter.PAYLOAD))
        scripter.result = 'ExploitResult', scripter.finish(scripter.sock)
        scripter.RETURN(scripter.result)

        return scripter.script(filename)

    def pov(self):
        '''
        Write out the exploit in DARPA's POV format.

        TODO: No value information is accounted for, this will almost always just cause the register to be the value of 0,
        PC to be 0, or the address to leak to be 0
        TODO: No rerandomization has occured at this time, the POV will act as though the target's randomness is fixed
        TODO: if anyone cares about this, it should be done with a scripter
        '''
        actions = [ ]
        path = self.crash.prev
        s = self.exploit_state

        for a in path.history.actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                        continue

            if a.action == 'write':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                read_action = dedent("""\
                        <read>
                          <length>{}</length>
                          <data format="hex">{}</data>
                        </read>""").format(size, binascii.hexlify(sval).decode())
                actions.append(read_action)

            if a.action == 'read':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                write_action = dedent("""\
                        <write>
                          <data format="hex">{}</data>
                        </write>""").format(binascii.hexlify(sval).decode())
                actions.append(write_action)

        body = '\n'.join(actions)

        pov = dedent("""\
                <pov>
                  <cbid>{}</cbid>
                  <replay>
                {}
                  </replay>
                </pov>""").format(os.path.basename(self.binary), body)

        return pov

    def _windup_state(self, state, to_syscall=False):
        '''
        Windup the state to a desired point, by default an unconstrained successors. This is helpful
        for applying constraints after a ROP chain has executed or a system call is about to occur so
        constraints can further be applied to the states.
        :param state: the SimState to windup
        :param to_syscall: if we should stop at syscall opposed to an unconstrained successor
        :return: a new state woundup
        '''

        state.options.add(angr.options.BYPASS_UNSUPPORTED_SYSCALL)

        successors = self.project.factory.successors(state)
        if len(successors.flat_successors) + len(successors.unconstrained_successors) != 1:
            raise ExploitException("path does not get to a single succesor")
        if to_syscall and self._at_syscall(state):
            return state
        if len(successors.flat_successors) == 1:
            return self._windup_state(successors.flat_successors[0], to_syscall)
        if len(successors.unconstrained_successors) > 0:
            return successors.unconstrained_successors[0]

        raise ExploitException("state did not reach an unconstrained successor or make syscall")
