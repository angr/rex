import binascii
import logging
import os
import struct

from textwrap import dedent

import angr
from angr.storage.file import SimFileDescriptorDuplex

from ..enums import CrashInputType

l = logging.getLogger("rex.exploit.exploit")


class ExploitException(Exception):
    pass


class Exploit:
    """
    An Exploit object represents the successful application of an exploit technique to a crash state.

    It contains the logic for extracting an understanding of how to interact with a state in order to reproduce it
    concretely, and then the logic for encoding that understanding as an exploit script.
    """

    def __init__(self, crash, bypasses_nx, bypasses_aslr, target_instruction_pointer = None):
        """
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param bypasses_nx: does the exploit bypass NX?
        :param bypasses_aslr: does the exploit bypass ASLR?
        :param target_ip_addr: what is the address that we are trying to control? This way we can parameterize it a bit
        """

        self.bypasses_nx = bypasses_nx
        self.bypasses_aslr = bypasses_aslr

        self.crash = crash
        self.binary = crash.binary
        self.project = crash.project

        self.exploit_state = crash.state

        self._script_string = None
        self.target_instruction_pointer = target_instruction_pointer

    def _at_syscall(self, path):
        """
        Is the current path at a syscall instruction? Will it make a syscall next step?
        :param path: the path to test
        :return: True if a syscall will be executed next step
        """

        return self.project.factory.block(path.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def reuse_input_constraints(self, sim_file, idx, inp):
        # binary search to use input for uncontrained bytes
        state = sim_file.state

        # end of binary search
        if len(inp) == 0:
            return []
        if len(inp) == 1:
            byte_value = sim_file.load(idx, 1)
            if not state.solver.satisfiable(extra_constraints=[byte_value == inp[0]]):
                return []
            else:
                return [byte_value == inp[0]]

        # try to add constraints on the whole input
        sym_value = sim_file.load(idx, len(inp))
        if state.solver.satisfiable(extra_constraints=[sym_value == inp]):
            return [sym_value == inp]

        # recursive logic
        bound = len(inp)//2
        constraints = self.reuse_input_constraints(sim_file, idx, inp[:bound]) + \
            self.reuse_input_constraints(sim_file, idx+bound, inp[bound:])
        return constraints

    def dump(self, filename=None):
        """
        default behavior for payload dumper
        """

        # Determine where data goes (stdin/tcp)

        if self.crash.input_type in (CrashInputType.STDIN, CrashInputType.POV_FILE):
            exploit_input = self.crash.state.posix.stdin  # stdin
        elif self.crash.input_type == CrashInputType.TCP:
            # determine which TCP socket file the input is coming from
            sock_fds = [ fd for fd_no, fd in self.crash.state.posix.fd.items() if fd_no not in (0, 1, 2) ] + \
                       [ fd for _, fd in self.crash.state.posix.closed_fds ]
            for simfd in sock_fds:
                if isinstance(simfd, SimFileDescriptorDuplex) and \
                        simfd.read_storage.ident.startswith("aeg_stdin") and \
                        self.crash.state.solver.eval(simfd.read_pos) > 0:
                    # found it!
                    exploit_input = simfd.read_storage
                    break
            else:
                raise ExploitException("Cannot find the exploit input file descriptor.")

        else:
            raise NotImplementedError("CrashInputType %s is not supported yet." % self.crash.input_type)

        # concretize the payload, if use_crash_input is enabled, use the original crash input
        # for unconstrained bytes
        if self.crash.use_crash_input:
            extra_constraints = self.reuse_input_constraints(exploit_input, 0, self.crash.crash_input)
            data = exploit_input.concretize(extra_constraints=extra_constraints)
        else:
            data = exploit_input.concretize()

        if isinstance(data, tuple):
            data = data[0]
        if filename:
            with open(filename, "wb") as f:
                f.write(data)
        return data

    def script(self, filename=None, parameterize_target_ip=False):
        if self._script_string is None:
            self._script_string = self._write_script(parameterize_target_ip=parameterize_target_ip)
        if filename:
            # output to file
            with open(filename, 'w') as f:
                f.write(self._script_string)
        return self._script_string

    def _write_script(self, parameterize_target_ip=False):

        if self.crash.input_type in (CrashInputType.STDIN, CrashInputType.POV_FILE):
            actions = self._script_get_actions_stdin(parameterize_target_ip=parameterize_target_ip)
        elif self.crash.input_type == CrashInputType.TCP:
            actions = self._script_get_actions_tcp(parameterize_target_ip=parameterize_target_ip)
        else:
            raise NotImplementedError("Unsupported crash input type %s." % self.crash.input_type)


        if parameterize_target_ip:
            body_parameters = {"target_instruction_pointer": hex(self.target_instruction_pointer)}
        else:
            body_parameters = {}

        body = os.linesep.join(actions)

        preamble = self._create_preamble(body_parameters)

        tail = self._create_tail(body_parameters)

        return preamble + body + tail

    def _create_argparse(self, parser_name, parameter, default):
        return """{parser}.add_argument('--{parameter}', default='{default}')""".format(parser=parser_name,
                                                                                       parameter=parameter,
                                                                                       default=default)

    def _create_preamble(self, parameters):
        extra_parsers = [self._create_argparse("parser", p, default) for p, default in parameters.items()]

        p = """
import argparse
import struct
import sys
import time

import nclib

parser = argparse.ArgumentParser(description="Launch exploit.")
parser.add_argument('host')
parser.add_argument('port')
parser.add_argument('-c', '--cmd', nargs="*")
{extra_parsers}

args = parser.parse_args()

r = nclib.Netcat((args.host, int(args.port)), udp=False)
"""
        return p.format(extra_parsers= os.linesep.join(extra_parsers))

    def _create_tail(self, parameters):
        p = """
if args.cmd:
    for c in args.cmd:
        time.sleep(.1)
        r.send_line(c.encode())
        time.sleep(.1)
        print(r.recv(timeout=4).decode('utf-8'), end="")
else:
    r.interact()
"""

        return p

    def _script_get_actions_tcp(self, parameterize_target_ip=False):

        actions = ["p = b''"]

        content = self.dump()

        added_actions = False
        if parameterize_target_ip:
            # HACK: try to just find the target IP in the payload
            # If we find it, replace it with a run-time replacement
            l.debug("Trying to parameterize the target instruction pointer in the payload")

            if not self.target_instruction_pointer:
                l.warning("Tried to parameterize the target instruction pointer without initializing me with the actual target instruction pointer")
            else:
                arch_bits_to_struct_format = {32: [b"<I", b">I"],
                                              64: [b"<Q", b">Q"]}
                bits = self.exploit_state.arch.bits
                if not bits in arch_bits_to_struct_format:
                    l.warning("Cannot parameterize the target instruction pointer on %d-bit arch", bits)
                else:
                    for fmt in arch_bits_to_struct_format[bits]:
                        ip = struct.pack(fmt, self.target_instruction_pointer)
                        start = content.find(ip)
                        if start != -1:
                            actions.append("# Before saved IP")
                            actions.append("p += %s" % content[:start])

                            actions.append("# calculate saved IP")
                            actions.append("""p += struct.pack(%s, int(args.target_instruction_pointer, 16))""" % (fmt,))

                            actions.append("# after saved IP")
                            actions.append("p += %s" % content[start+len(ip):])
                            added_actions = True
                            break

        if not added_actions:
            actions.append("p += %s" % content)
        actions.append("r.send(p)")
        return actions

    def _script_get_actions_stdin(self, parameterize_target_ip=False):
        # FIXME: This method is deprecated. remove it later
        return self._script_get_actions_tcp(parameterize_target_ip=parameterize_target_ip)

    def pov(self):
        '''
        Write out the exploit in DARPA's POV format.

        TODO: No value information is accounted for, this will almost always just cause the register to be the value of 0,
        PC to be 0, or the address to leak to be 0
        TODO: No rerandomization has occured at this time, the POV will act as though the target's randomness is fixed
        '''

        actions = [ ]
        path = self.crash.prev
        s = self.exploit_state

        for a in path.history.actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                        continue

            if a.action == 'write':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                read_action = dedent("""\
                        <read>
                          <length>{}</length>
                          <data format="hex">{}</data>
                        </read>""").format(size, binascii.hexlify(sval).decode())
                actions.append(read_action)

            if a.action == 'read':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                write_action = dedent("""\
                        <write>
                          <data format="hex">{}</data>
                        </write>""").format(binascii.hexlify(sval).decode())
                actions.append(write_action)

        body = '\n'.join(actions)

        pov = dedent("""\
                <pov>
                  <cbid>{}</cbid>
                  <replay>
                {}
                  </replay>
                </pov>""").format(os.path.basename(self.binary), body)

        return pov

    def _windup_state(self, state, to_syscall=False):
        '''
        Windup the state to a desired point, by default an unconstrained successors. This is helpful
        for applying constraints after a ROP chain has executed or a system call is about to occur so
        constraints can further be applied to the states.
        :param state: the SimState to windup
        :param to_syscall: if we should stop at syscall opposed to an unconstrained successor
        :return: a new state woundup
        '''

        state.options.add(angr.options.BYPASS_UNSUPPORTED_SYSCALL)

        successors = self.project.factory.successors(state)
        if len(successors.flat_successors) + len(successors.unconstrained_successors) != 1:
            raise ExploitException("path does not get to a single succesor")
        if to_syscall and self._at_syscall(state):
            return state
        if len(successors.flat_successors) == 1:
            return self._windup_state(successors.flat_successors[0], to_syscall)
        if len(successors.unconstrained_successors) > 0:
            return successors.unconstrained_successors[0]

        raise ExploitException("state did not reach an unconstrained successor or make syscall")
