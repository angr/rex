import os
import logging
import binascii
from textwrap import dedent

import angr
from angr.storage.file import SimFileDescriptorDuplex

from ..enums import CrashInputType

l = logging.getLogger("rex.exploit.exploit")


class ExploitException(Exception):
    pass


class Exploit:
    """
    An Exploit object represents the successful application of an exploit technique to a crash state.

    It contains the logic for extracting an understanding of how to interact with a state in order to reproduce it
    concretely, and then the logic for encoding that understanding as an exploit script.
    """

    def __init__(self, crash, bypasses_nx, bypasses_aslr):
        """
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param bypasses_nx: does the exploit bypass NX?
        :param bypasses_aslr: does the exploit bypass ASLR?
        """

        self.bypasses_nx = bypasses_nx
        self.bypasses_aslr = bypasses_aslr

        self.crash = crash
        self.binary = crash.binary
        self.project = crash.project

        self.exploit_state = crash.state

        self._script_string = None

    def _at_syscall(self, path):
        """
        Is the current path at a syscall instruction? Will it make a syscall next step?
        :param path: the path to test
        :return: True if a syscall will be executed next step
        """

        return self.project.factory.block(path.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def dump(self, filename=None):
        """
        default behavior for payload dumper
        """

        # Determine where data goes (stdin/tcp)

        if self.crash.input_type in (CrashInputType.STDIN, CrashInputType.POV_FILE):
            exploit_input = self.crash.state.posix.stdin  # stdin
        elif self.crash.input_type == CrashInputType.TCP:
            # determine which TCP socket file the input is coming from
            sock_fds = [ fd for fd_no, fd in self.crash.state.posix.fd.items() if fd_no not in (0, 1, 2) ] + \
                       [ fd for _, fd in self.crash.state.posix.closed_fds ]
            for simfd in sock_fds:
                if isinstance(simfd, SimFileDescriptorDuplex) and \
                        simfd.read_storage.ident.startswith("aeg_stdin") and \
                        self.crash.state.solver.eval(simfd.read_pos) > 0:
                    # found it!
                    exploit_input = simfd.read_storage
                    break
            else:
                raise ExploitException("Cannot find the exploit input file descriptor.")

        else:
            raise NotImplementedError("CrashInputType %s is not supported yet." % self.crash.input_type)

        data = exploit_input.concretize()
        if isinstance(data, tuple):
            data = data[0]
        if filename:
            with open(filename, "wb") as f:
                f.write(data)
        return data

    def script(self, filename=None):
        if self._script_string is None:
            self._script_string = self._write_script()
        if not filename:
            # output to stdout
            print(self._script_string)
        else:
            # output to file
            with open(filename, 'w') as f:
                f.write(self._script_string)
        return self._script_string

    def _write_script(self):

        if self.crash.input_type in (CrashInputType.STDIN, CrashInputType.POV_FILE):
            actions = self._script_get_actions_stdin()
        elif self.crash.input_type == CrashInputType.TCP:
            actions = self._script_get_actions_tcp()
        else:
            raise NotImplementedError("Unsupported crash input type %s." % self.crash.input_type)

        body = os.linesep.join(actions)

        preamble = """
import sys
import time
import nclib

if len(sys.argv) < 3:
    print("%s: <host> <port> [<cmd 1> <cmd 2> ...]" % sys.argv[0])
    sys.exit(1)

r = nclib.Netcat((sys.argv[1], int(sys.argv[2])), udp=False)
"""

        tail = """
if len(sys.argv) > 3:
    for i in range(3, len(sys.argv)):
        time.sleep(.1)
        r.send_line(sys.argv[i].encode())
        time.sleep(.1)
        print(r.recv(timeout=4).decode('utf-8'), end="")
else:
    r.interact()
"""

        return preamble + body + tail

    def _script_get_actions_tcp(self):

        actions = [ ]

        content = self.dump()
        actions.append("r.send(%s)" % content)

        return actions

    def _script_get_actions_stdin(self):

        actions = [ ]

        path = self.crash.prev
        s = self.exploit_state

        last_action = None
        for a in path.history.actions.hardcopy + self.crash.added_actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                continue

            if a.action == 'write':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                actions.append("r.readuntil(%r)" % sval)
                last_action = a.action

            if a.action == 'read':
                size = s.solver.eval(a.size.ast)
                concrete = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                if last_action == 'read':
                    actions.append('time.sleep(.1)')
                actions.append("r.send(%r)" % concrete)
                last_action = a.action

        return actions

    def pov(self):
        '''
        Write out the exploit in DARPA's POV format.

        TODO: No value information is accounted for, this will almost always just cause the register to be the value of 0,
        PC to be 0, or the address to leak to be 0
        TODO: No rerandomization has occured at this time, the POV will act as though the target's randomness is fixed
        '''

        actions = [ ]
        path = self.crash.prev
        s = self.exploit_state

        for a in path.history.actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                        continue

            if a.action == 'write':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                read_action = dedent("""\
                        <read>
                          <length>{}</length>
                          <data format="hex">{}</data>
                        </read>""").format(size, binascii.hexlify(sval).decode())
                actions.append(read_action)

            if a.action == 'read':
                size = s.solver.eval(a.size.ast)
                sval = s.solver.eval(a.data.ast, cast_to=bytes)[:size]
                write_action = dedent("""\
                        <write>
                          <data format="hex">{}</data>
                        </write>""").format(binascii.hexlify(sval).decode())
                actions.append(write_action)

        body = '\n'.join(actions)

        pov = dedent("""\
                <pov>
                  <cbid>{}</cbid>
                  <replay>
                {}
                  </replay>
                </pov>""").format(os.path.basename(self.binary), body)

        return pov

    def _windup_state(self, state, to_syscall=False):
        '''
        Windup the state to a desired point, by default an unconstrained successors. This is helpful
        for applying constraints after a ROP chain has executed or a system call is about to occur so
        constraints can further be applied to the states.
        :param state: the SimState to windup
        :param to_syscall: if we should stop at syscall opposed to an unconstrained successor
        :return: a new state woundup
        '''

        state.options.add(angr.options.BYPASS_UNSUPPORTED_SYSCALL)

        successors = self.project.factory.successors(state)
        if len(successors.flat_successors) + len(successors.unconstrained_successors) != 1:
            raise ExploitException("path does not get to a single succesor")
        if to_syscall and self._at_syscall(state):
            return state
        if len(successors.flat_successors) == 1:
            return self._windup_state(successors.flat_successors[0], to_syscall)
        if len(successors.unconstrained_successors) > 0:
            return successors.unconstrained_successors[0]

        raise ExploitException("state did not reach an unconstrained successor or make syscall")
